// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createElection = `-- name: CreateElection :one
INSERT INTO elections (name, election_date) VALUES ($1, $2) RETURNING id
`

type CreateElectionParams struct {
	Name         string
	ElectionDate pgtype.Date
}

func (q *Queries) CreateElection(ctx context.Context, arg CreateElectionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createElection, arg.Name, arg.ElectionDate)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createParty = `-- name: CreateParty :one
INSERT INTO parties (name, short_name) VALUES ($1, $2) RETURNING id
`

type CreatePartyParams struct {
	Name      string
	ShortName pgtype.Text
}

func (q *Queries) CreateParty(ctx context.Context, arg CreatePartyParams) (int32, error) {
	row := q.db.QueryRow(ctx, createParty, arg.Name, arg.ShortName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createPartyStance = `-- name: CreatePartyStance :one
INSERT INTO party_stances (party_id, question_id, stance) VALUES ($1, $2, $3) RETURNING id
`

type CreatePartyStanceParams struct {
	PartyID    int32
	QuestionID int32
	Stance     int32
}

func (q *Queries) CreatePartyStance(ctx context.Context, arg CreatePartyStanceParams) (int32, error) {
	row := q.db.QueryRow(ctx, createPartyStance, arg.PartyID, arg.QuestionID, arg.Stance)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (election_id, title, question_text, description, display_order) VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type CreateQuestionParams struct {
	ElectionID   int32
	Title        string
	QuestionText string
	Description  pgtype.Text
	DisplayOrder int32
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (int32, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.ElectionID,
		arg.Title,
		arg.QuestionText,
		arg.Description,
		arg.DisplayOrder,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getAllParties = `-- name: GetAllParties :many
SELECT id, name FROM parties
`

type GetAllPartiesRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetAllParties(ctx context.Context) ([]GetAllPartiesRow, error) {
	rows, err := q.db.Query(ctx, getAllParties)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPartiesRow
	for rows.Next() {
		var i GetAllPartiesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getElectionByName = `-- name: GetElectionByName :one
SELECT id FROM elections WHERE name = $1
`

func (q *Queries) GetElectionByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getElectionByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getLatestElection = `-- name: GetLatestElection :one
SELECT id, name FROM elections ORDER BY election_date DESC LIMIT 1
`

type GetLatestElectionRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetLatestElection(ctx context.Context) (GetLatestElectionRow, error) {
	row := q.db.QueryRow(ctx, getLatestElection)
	var i GetLatestElectionRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getPartyByName = `-- name: GetPartyByName :one
SELECT id FROM parties WHERE name = $1
`

func (q *Queries) GetPartyByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getPartyByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPartyStancesByElectionID = `-- name: GetPartyStancesByElectionID :many
SELECT ps.question_id, ps.party_id, ps.stance, p.name as party_name
FROM party_stances ps
JOIN questions q ON ps.question_id = q.id
JOIN parties p ON ps.party_id = p.id
WHERE q.election_id = $1
`

type GetPartyStancesByElectionIDRow struct {
	QuestionID int32
	PartyID    int32
	Stance     int32
	PartyName  string
}

func (q *Queries) GetPartyStancesByElectionID(ctx context.Context, electionID int32) ([]GetPartyStancesByElectionIDRow, error) {
	rows, err := q.db.Query(ctx, getPartyStancesByElectionID, electionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPartyStancesByElectionIDRow
	for rows.Next() {
		var i GetPartyStancesByElectionIDRow
		if err := rows.Scan(
			&i.QuestionID,
			&i.PartyID,
			&i.Stance,
			&i.PartyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionByTitleAndElectionID = `-- name: GetQuestionByTitleAndElectionID :one
SELECT id FROM questions WHERE title = $1 AND election_id = $2
`

type GetQuestionByTitleAndElectionIDParams struct {
	Title      string
	ElectionID int32
}

func (q *Queries) GetQuestionByTitleAndElectionID(ctx context.Context, arg GetQuestionByTitleAndElectionIDParams) (int32, error) {
	row := q.db.QueryRow(ctx, getQuestionByTitleAndElectionID, arg.Title, arg.ElectionID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getQuestionsByElectionID = `-- name: GetQuestionsByElectionID :many
SELECT id, title, question_text, description FROM questions WHERE election_id = $1 ORDER BY display_order ASC
`

type GetQuestionsByElectionIDRow struct {
	ID           int32
	Title        string
	QuestionText string
	Description  pgtype.Text
}

func (q *Queries) GetQuestionsByElectionID(ctx context.Context, electionID int32) ([]GetQuestionsByElectionIDRow, error) {
	rows, err := q.db.Query(ctx, getQuestionsByElectionID, electionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuestionsByElectionIDRow
	for rows.Next() {
		var i GetQuestionsByElectionIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.QuestionText,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateAllTables = `-- name: TruncateAllTables :exec
TRUNCATE TABLE party_stances, questions, parties, elections RESTART IDENTITY CASCADE
`

func (q *Queries) TruncateAllTables(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateAllTables)
	return err
}
